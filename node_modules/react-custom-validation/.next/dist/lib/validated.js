'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inherits2 = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.validated = validated;

var _extends2 = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('/home/marcelka/projects/validation/node_modules/next/node_modules/babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _react = require('/home/marcelka/projects/validation/node_modules/react/react.js');

var _react2 = _interopRequireDefault(_react);

var _immutabilityHelper = require('immutability-helper');

var _immutabilityHelper2 = _interopRequireDefault(_immutabilityHelper);

var _lodash = require('lodash');

var _config = require('./config');

var _fields = require('./fields');

var _results = require('./results');

var _submit = require('./submit');

var _state = require('./state');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

function updateValidationData(state) {
  var results = state.results,
      fields = state.fields,
      _state$config = state.config,
      onValidation = _state$config.onValidation,
      validations = _state$config.validations;

  var validationData = {};
  for (var name in validations) {
    validationData[name] = (0, _lodash.cloneDeep)(results[name].result);
    validationData[name].show = (0, _fields.shouldShowValidation)(validations[name].fields, fields);
    if (!(0, _lodash.isEqual)(validationData[name], state.validationData[name])) {
      onValidation(name, validationData[name]);
    }
  }
  return (0, _immutabilityHelper2.default)(state, { validationData: { $set: validationData } });
}

function validated(getConfig) {
  return function (Component) {
    var _class, _temp2;

    return _temp2 = _class = function (_React$Component) {
      (0, _inherits3.default)(_class, _React$Component);

      function _class() {
        var _ref;

        var _temp, _this, _ret;

        (0, _classCallCheck3.default)(this, _class);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = _class.__proto__ || (0, _getPrototypeOf2.default)(_class)).call.apply(_ref, [this].concat(args))), _this), _this.fieldEvent = function (type, field, debounce) {
          // Cancel submitting if user is still changing data in the form or if the
          // form was reset
          if (type === 'change' || type === 'reset') {
            _this.registry = (0, _submit.resetSubmit)(_this.registry);
          }

          var dispatchUpdate = function dispatchUpdate(fn) {
            var oldRegistry = _this.registry;
            if (!_this.registry.isMounted) {
              return;
            }
            _this.registry = fn(_this.registry);
            _this.registry = updateValidationData(_this.registry);
            _this.forceUpdateIfNeeded(oldRegistry, _this.registry);
          };
          (0, _fields.handleFieldEvent)(dispatchUpdate, field, type, debounce);
        }, _this.field = function (field, handleChange, handleBlur, debounce) {
          return {
            onChange: function onChange(e) {
              _this.fieldEvent('change', field, debounce);
              return (handleChange || function () {})(e);
            },
            onBlur: function onBlur(e) {
              _this.fieldEvent('blur', field, false);
              return (handleBlur || function () {})(e);
            }
          };
        }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
      }

      (0, _createClass3.default)(_class, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
          this.registry = (0, _state.initialState)((0, _config.normalizeConfig)(getConfig(this.props)));
          this.componentWillReceiveProps(this.props);
        }
      }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
          var _this2 = this;

          var config = (0, _config.normalizeConfig)(getConfig(nextProps));

          // Cancel submitting if user is still changing data in the form
          if (!(0, _lodash.isEqual)(this.registry.config.validations, config.validations)) {
            this.registry = (0, _submit.resetSubmit)(this.registry);
          }

          this.registry = (0, _immutabilityHelper2.default)(this.registry, { config: { $set: config } });

          var dispatchUpdate = function dispatchUpdate(fn) {
            var oldRegistry = _this2.registry;
            if (!_this2.registry.isMounted) {
              return;
            }
            _this2.registry = fn(_this2.registry);
            _this2.registry = updateValidationData(_this2.registry);
            _this2.registry = (0, _submit.updateSubmit)(_this2.registry);
            _this2.forceUpdateIfNeeded(oldRegistry, _this2.registry);
          };
          (0, _results.updateResults)(dispatchUpdate);
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          this.registry = (0, _immutabilityHelper2.default)(this.registry, { isMounted: { $set: false } });
        }
      }, {
        key: 'forceUpdateIfNeeded',
        value: function forceUpdateIfNeeded(oldRegistry, newRegistry) {
          if (!(0, _lodash.isEqual)(oldRegistry.validationData, newRegistry.validationData)) {
            canUseDOM() && this.forceUpdate();
          }
        }
      }, {
        key: 'render',
        value: function render() {
          var _this3 = this;

          var validationProps = {
            $validation: this.registry.validationData,
            $fieldEvent: this.fieldEvent,
            $field: this.field,
            $submit: function $submit(onValid, onInvalid) {
              var fieldEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

              if (fieldEvent) {
                _this3.fieldEvent('submit');
              }
              _this3.registry = (0, _submit.submit)(_this3.registry, onValid, onInvalid);
            }
          };
          for (var p in validationProps) {
            if (p in this.props) {
              var message = 'Naming collision: validated component ' + (Component.name || Component.displayName) + ' ' + ('cannot receive prop ' + p + ', as this prop name is reserved by the validation library.');
              throw new Error(message);
            }
          }
          return _react2.default.createElement(Component, (0, _extends3.default)({}, this.props, validationProps));
        }
      }]);
      return _class;
    }(_react2.default.Component), _class.displayName = 'Validated-' + (Component.name || Component.displayName), _temp2;
  };
}